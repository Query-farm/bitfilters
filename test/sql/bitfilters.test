# name: test/sql/bitfilters.test
# description: test bitfilters extension
# group: [sql]

# Require statement will ensure this test is run with this extension loaded
require bitfilters

# Create some example data.
statement ok
create table series_data as (select * as id from generate_series(1, 100000) as id)

#statement ok
#create table bloom_filters as (
#  select id % 2 as remainder, bloomfilter(10000, 0.1, id) as filter
#  from series_data
#  group by id % 2
#);

#query II
#select remainder,
#count(case when bloom_filter_contains(filter, id) then 1 else null end) as is_contained
#from series_data,
#bloom_filters where series_data.id % 2 == bloom_filters.remainder group by remainder;
#----
#0	5000
#1	5000

#query II
#select remainder, count(case when bloom_filter_contains(filter, id) then 1 else null end) as false_positives
#from series_data, bloom_filters where series_data.id % 2 != bloom_filters.remainder group by remainder;
#----
#0	46
#1	41

# Create a quotient filter with q=16 and r=4.
statement ok
create table quotient_filters as (
  select id % 2 as remainder,
  quotient_filter(16, 4, hash(id)) as filter
  from series_data
  group by id % 2
);

# Check for false positives in the quotient filter.
query II
select remainder,
count(case when quotient_filter_contains(filter, hash(id)) then 1 else null end) as false_positives
from series_data, quotient_filters
where
series_data.id % 2 != quotient_filters.remainder group by remainder;
----
0	2264
1	2273

# Create some XOR filters.
statement ok
create table xor_filters as (
  select id % 2 as remainder,
  xor16_filter(hash(id)) as xor16_filter,
  xor8_filter(hash(id)) as xor8_filter
  from series_data
  group by id % 2
);

# Check that the filters contain whats expected.
query III
select remainder,
count(case when xor16_filter_contains(xor16_filter, hash(id)) then 1 else null end) as xor16_is_contained,
count(case when xor8_filter_contains(xor8_filter, hash(id)) then 1 else null end) as xor8_is_contained
from series_data, xor_filters
where
series_data.id % 2 == xor_filters.remainder
group by remainder;
----
0	50000	50000
1	50000	50000

# It seems that the false positives aren't deterministic, so disable this test for now.

#query III
#select remainder,
#count(case when xor16_filter_contains(xor16_filter, hash(id)) then 1 else null end) as xor16_false_positives,
#count(case when xor8_filter_contains(xor8_filter, hash(id)) then 1 else null end) as xor8_false_positives
#from series_data, xor_filters where series_data.id % 2 != xor_filters.remainder group by remainder;
#----
#0	1	184
#0	3	211

statement ok
create table binary_fuse_filters as (
  select id % 2 as remainder,
  binary_fuse16_filter(hash(id)) as binary_fuse16_filter,
  binary_fuse8_filter(hash(id)) as binary_fuse8_filter
  from series_data
  group by id % 2
);

query III
select remainder,
count(case when binary_fuse16_filter_contains(binary_fuse16_filter, hash(id)) then 1 else null end) as binary_fuse16_is_contained,
count(case when binary_fuse8_filter_contains(binary_fuse8_filter, hash(id)) then 1 else null end) as binary_fuse8_is_contained
from series_data, binary_fuse_filters
where
series_data.id % 2 == binary_fuse_filters.remainder
group by remainder;
----
0	50000	50000
1	50000	50000

query III
select remainder,
count(case when binary_fuse16_filter_contains(binary_fuse16_filter, hash(id)) then 1 else null end) as binary_fuse16_false_positives,
count(case when binary_fuse8_filter_contains(binary_fuse8_filter, hash(id)) then 1 else null end) as binary_fuse8_false_positives
from series_data, binary_fuse_filters where series_data.id % 2 != binary_fuse_filters.remainder group by remainder;
----
0	1	171
1	1	199
